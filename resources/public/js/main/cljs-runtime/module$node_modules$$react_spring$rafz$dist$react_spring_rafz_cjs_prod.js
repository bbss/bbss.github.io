shadow$provide.module$node_modules$$react_spring$rafz$dist$react_spring_rafz_cjs_prod=function(global,require,module,exports){function schedule(fn,queue){sync?(queue.delete(fn),fn(0)):(queue.add(fn),start())}function start(){0>ts&&(ts=0,"demand"!==raf.frameLoop&&nativeRaf(loop))}function loop(){~ts&&(nativeRaf(loop),raf.batchedUpdates(update))}function update(){let prevTs=ts;ts=raf.now();let count=findTimeout(ts);count&&(eachSafely(timeouts.splice(0,count),t=>t.handler()),__raf.count-=count);onStartQueue.flush();
updateQueue.flush(prevTs?Math.min(64,ts-prevTs):16.667);onFrameQueue.flush();writeQueue.flush();onFinishQueue.flush()}function makeQueue(){let next=new Set,current=next;return{add(fn){__raf.count+=current!=next||next.has(fn)?0:1;next.add(fn)},delete(fn){__raf.count-=current==next&&next.has(fn)?1:0;return next.delete(fn)},flush(arg){current.size&&(next=new Set,__raf.count-=current.size,eachSafely(current,fn=>fn(arg)&&next.add(fn)),__raf.count+=next.size,current=next)}}}function eachSafely(values,each){values.forEach(value=>
{try{each(value)}catch(e){raf.catch(e)}})}Object.defineProperty(exports,"__esModule",{value:!0});let updateQueue=makeQueue();const raf=fn=>schedule(fn,updateQueue);let writeQueue=makeQueue();raf.write=fn=>schedule(fn,writeQueue);let onStartQueue=makeQueue();raf.onStart=fn=>schedule(fn,onStartQueue);let onFrameQueue=makeQueue();raf.onFrame=fn=>schedule(fn,onFrameQueue);let onFinishQueue=makeQueue();raf.onFinish=fn=>schedule(fn,onFinishQueue);let timeouts=[];raf.setTimeout=(handler,ms)=>{ms=raf.now()+
ms;let cancel=()=>{let i=timeouts.findIndex(t=>t.cancel==cancel);~i&&timeouts.splice(i,1);__raf.count-=~i?1:0};handler={time:ms,handler,cancel};timeouts.splice(findTimeout(ms),0,handler);__raf.count+=1;start();return handler};let findTimeout=time=>~(~timeouts.findIndex(t=>t.time>time)||~timeouts.length);raf.cancel=fn=>{updateQueue.delete(fn);writeQueue.delete(fn)};raf.sync=fn=>{sync=!0;raf.batchedUpdates(fn);sync=!1};raf.throttle=fn=>{function queuedFn(){try{fn(...lastArgs)}finally{lastArgs=null}}
function throttled(...args){lastArgs=args;raf.onStart(queuedFn)}let lastArgs;throttled.handler=fn;throttled.cancel=()=>{onStartQueue.delete(queuedFn);lastArgs=null};return throttled};let nativeRaf="undefined"!=typeof window?window.requestAnimationFrame:()=>{};raf.use=impl=>nativeRaf=impl;raf.now="undefined"!=typeof performance?()=>performance.now():Date.now;raf.batchedUpdates=fn=>fn();raf.catch=console.error;raf.frameLoop="always";raf.advance=()=>{"demand"!==raf.frameLoop?console.warn("Cannot call the manual advancement of rafz whilst frameLoop is not set as demand"):
update()};let ts=-1,sync=!1;const __raf={count:0,clear(){ts=-1;timeouts=[];onStartQueue=makeQueue();updateQueue=makeQueue();onFrameQueue=makeQueue();writeQueue=makeQueue();onFinishQueue=makeQueue();__raf.count=0}};exports.__raf=__raf;exports.raf=raf}
//# sourceMappingURL=module$node_modules$$react_spring$rafz$dist$react_spring_rafz_cjs_prod.js.map
