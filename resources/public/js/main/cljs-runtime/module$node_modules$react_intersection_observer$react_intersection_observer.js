shadow$provide.module$node_modules$react_intersection_observer$react_intersection_observer=function(global,require,module,exports){function _extends(){_extends=Object.assign||function(target){for(var i=1;i<arguments.length;i++){var source=arguments[i],key;for(key in source)Object.prototype.hasOwnProperty.call(source,key)&&(target[key]=source[key])}return target};return _extends.apply(this,arguments)}function _inheritsLoose(subClass,superClass){subClass.prototype=Object.create(superClass.prototype);
subClass.prototype.constructor=subClass;subClass.__proto__=superClass}function optionsToId(options){return Object.keys(options).sort().filter(function(key){return void 0!==options[key]}).map(function(key){var JSCompiler_temp;"root"===key?(JSCompiler_temp=options.root)?(RootIds.has(JSCompiler_temp)||(rootId+=1,RootIds.set(JSCompiler_temp,rootId.toString())),JSCompiler_temp=RootIds.get(JSCompiler_temp)):JSCompiler_temp="0":JSCompiler_temp=options[key];return key+"_"+JSCompiler_temp}).toString()}function createObserver(options){var id=
optionsToId(options),instance=ObserverMap.get(id);if(!instance){var elements=new Map;instance=new IntersectionObserver(function(entries){entries.forEach(function(entry){var _elements$get,inView=entry.isIntersecting&&thresholds.some(function(threshold){return entry.intersectionRatio>=threshold});options.trackVisibility&&"undefined"===typeof entry.isVisible&&(entry.isVisible=inView);null==(_elements$get=elements.get(entry.target))?void 0:_elements$get.forEach(function(callback){callback(inView,entry)})})},
options);var thresholds=instance.thresholds||(Array.isArray(options.threshold)?options.threshold:[options.threshold||0]);instance={id,observer:instance,elements};ObserverMap.set(id,instance)}return instance}function observe(element,callback,options){void 0===options&&(options={});if(!element)return function(){};options=createObserver(options);var id=options.id,observer=options.observer,elements=options.elements,callbacks=elements.get(element)||[];elements.has(element)||elements.set(element,callbacks);
callbacks.push(callback);observer.observe(element);return function(){callbacks.splice(callbacks.indexOf(callback),1);0===callbacks.length&&(elements["delete"](element),observer.unobserve(element));0===elements.size&&(observer.disconnect(),ObserverMap["delete"](id))}}var React=require("module$node_modules$react$index"),ObserverMap=new Map,RootIds=new WeakMap,rootId=0;global=function(_React$Component){function InView(props){var _this=_React$Component.call(this,props)||this;_this.node=null;_this._unobserveCb=
null;_this.handleNode=function(node){_this.node&&(_this.unobserve(),node||_this.props.triggerOnce||_this.props.skip||_this.setState({inView:!!_this.props.initialInView,entry:void 0}));_this.node=node?node:null;_this.observeNode()};_this.handleChange=function(inView,entry){inView&&_this.props.triggerOnce&&_this.unobserve();"function"===typeof _this.props.children&&_this.setState({inView,entry});if(_this.props.onChange)_this.props.onChange(inView,entry)};_this.state={inView:!!props.initialInView,entry:void 0};
return _this}_inheritsLoose(InView,_React$Component);var _proto=InView.prototype;_proto.componentDidUpdate=function(prevProps){if(prevProps.rootMargin!==this.props.rootMargin||prevProps.root!==this.props.root||prevProps.threshold!==this.props.threshold||prevProps.skip!==this.props.skip||prevProps.trackVisibility!==this.props.trackVisibility||prevProps.delay!==this.props.delay)this.unobserve(),this.observeNode()};_proto.componentWillUnmount=function(){this.unobserve();this.node=null};_proto.observeNode=
function(){if(this.node&&!this.props.skip){var _this$props=this.props;this._unobserveCb=observe(this.node,this.handleChange,{threshold:_this$props.threshold,root:_this$props.root,rootMargin:_this$props.rootMargin,trackVisibility:_this$props.trackVisibility,delay:_this$props.delay})}};_proto.unobserve=function(){this._unobserveCb&&(this._unobserveCb(),this._unobserveCb=null)};_proto.render=function(){if("function"===typeof this.props.children){var _this$state=this.state;return this.props.children({inView:_this$state.inView,
entry:_this$state.entry,ref:this.handleNode})}var _this$props2=this.props;_this$state=_this$props2.children;var as=_this$props2.as,tag=_this$props2.tag;var excluded="children as tag triggerOnce threshold root rootMargin onChange skip trackVisibility delay initialInView".split(" ");if(null==_this$props2)_this$props2={};else{var target={},sourceKeys=Object.keys(_this$props2),i;for(i=0;i<sourceKeys.length;i++){var key=sourceKeys[i];0<=excluded.indexOf(key)||(target[key]=_this$props2[key])}_this$props2=
target}return React.createElement(as||tag||"div",_extends({ref:this.handleNode},_this$props2),_this$state)};return InView}(React.Component);global.displayName="InView";global.defaultProps={threshold:0,triggerOnce:!1,initialInView:!1};exports.InView=global;exports.default=global;exports.observe=observe;exports.useInView=function(_temp){_temp=void 0===_temp?{}:_temp;var threshold=_temp.threshold,delay=_temp.delay,trackVisibility=_temp.trackVisibility,rootMargin=_temp.rootMargin,root=_temp.root,triggerOnce=
_temp.triggerOnce,skip=_temp.skip,initialInView=_temp.initialInView,unobserve=React.useRef();_temp=React.useState({inView:!!initialInView});var state=_temp[0],setState=_temp[1];_temp=React.useCallback(function(node){void 0!==unobserve.current&&(unobserve.current(),unobserve.current=void 0);!skip&&node&&(unobserve.current=observe(node,function(inView,entry){setState({inView,entry});entry.isIntersecting&&triggerOnce&&unobserve.current&&(unobserve.current(),unobserve.current=void 0)},{root,rootMargin,
threshold,trackVisibility,delay}))},[Array.isArray(threshold)?threshold.toString():threshold,root,rootMargin,triggerOnce,skip,trackVisibility,delay]);React.useEffect(function(){unobserve.current||!state.entry||triggerOnce||skip||setState({inView:!!initialInView})});_temp=[_temp,state.inView,state.entry];_temp.ref=_temp[0];_temp.inView=_temp[1];_temp.entry=_temp[2];return _temp}}
//# sourceMappingURL=module$node_modules$react_intersection_observer$react_intersection_observer.js.map
