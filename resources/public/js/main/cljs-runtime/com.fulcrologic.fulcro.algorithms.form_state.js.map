{"version":3,"sources":["com/fulcrologic/fulcro/algorithms/form_state.cljc"],"mappings":"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","names":["com.fulcrologic.fulcro.algorithms.form-state/ident-generator","cljs.spec.alpha.gen","cljs.spec.alpha/def-impl","cljs.spec.alpha/with-gen","edn-query-language.core/ident?","cljs.spec.alpha.every_impl","G__64791","cljs.core/keyword?","cljs.core/set?","cljs.spec.alpha.tuple_impl","G__64795","cljs.core/map?","i__13412__auto__","v__13413__auto__","cljs.core.nth","cljs.core/any?","G__64796","G__64799","cljs.spec.alpha/or-spec-impl","cljs.spec.alpha/map-spec-impl","G__64836","cljs.core/contains?","cljs.spec.alpha/and-spec-impl","p1__64801#","cljs.core._EQ_","cljs.core/first","G__64978","com.fulcrologic.fulcro.algorithms.form-state/get-form-fields","class","com.fulcrologic.fulcro.raw.components.component_options","com.fulcrologic.fulcro.algorithms.form-state/form-id","entity-ident","cljs.core/second","com.fulcrologic.fulcro.algorithms.form-state/FormConfig","com.fulcrologic.fulcro.raw.components.nc","p__64999","map__65000","cljs.core/--destructure-map","cljs.core.get","_","id","com.fulcrologic.fulcro.algorithms.form-state/form-config-join","com.fulcrologic.fulcro.raw.components.get_query","var_args","G__65006","com.fulcrologic.fulcro.algorithms.form-state/form-config","js/Error","fields","com.fulcrologic.fulcro.algorithms.form_state.form_config","subforms","cljs.core.into","cljs.core.map","p__65008","vec__65009","k","v","cljs.core/with-meta","com.fulcrologic.fulcro.algorithms.form-state/derive-form-info","map__65016","query-nodes","G__65017","edn-query-language.core/query->ast","query-nodes-by-key","n","join-component","cljs.core.get_in","props","joins","cljs.core/group-by","join-keys","cljs.core/set","prop-keys","queries-for-config?","all-fields","has-fields?","cljs.core/seq","clojure.set.intersection","subform-keys","cljs.core.ex_info","com.fulcrologic.fulcro.raw.components/component-name","cljs.core/not","G__65049","com.fulcrologic.fulcro.algorithms.form-state/add-form-config","p__65050","map__65051","entity","com.fulcrologic.fulcro.algorithms.form_state.add_form_config","destructive?","opts","vec__65052","subform-classmap","local-entity","or__4223__auto__","pristine-state","cljs.core/select-keys","subform-ident","G__65055","cljs.core/meta","com.fulcrologic.fulcro.raw.components.get_ident","cljs.core/keys","subform-refs","cljs.core.reduce","refs","items","cljs.core.assoc","cljs.core/vector?","p1__65034#","cljs.core.mapv","cljs.core.merge","config","resulting-entity","c","G__65061","cljs.core/boolean","child","e65068","and__4221__auto__","p1__65035#","e","G__65095","com.fulcrologic.fulcro.algorithms.form-state/add-form-config*","p__65096","map__65097","state-map","com.fulcrologic.fulcro.algorithms.form_state.add_form_config_STAR_","vec__65098","updated-state-map","clojure.set.union","cfg-ident","cljs.core/assoc-in","cljs.core.conj","cljs.core/empty?","smap","subform-key","subform-class","G__65102","subform-target","e65103","cljs.core/every?","s","com.fulcrologic.fulcro.algorithms.form-state/immediate-subforms","subform-join-keys","cljs.core.remove","cljs.core/nil?","p1__65105#","cljs.core.mapcat","cljs.core/sequential?","com.fulcrologic.fulcro.algorithms.form-state/no-spec-or-valid?","entity-props","key","cljs.spec.alpha/get-spec","cljs.spec.alpha.valid_QMARK_","com.fulcrologic.fulcro.algorithms.form-state/merge-validity","a","b","com.fulcrologic.guardrails.core/=>","G__65124","com.fulcrologic.fulcro.algorithms.form-state/make-validator","p__65126","map__65129","field-valid?","com.fulcrologic.fulcro.algorithms.form_state.make_validator","validate-edges?","ui-entity-props","field","map__65141","map__65142","complete?","map__65147","map__65148","immediate-subforms","field-validity","current-validity","com$fulcrologic$fulcro$algorithms$form_state$custom_get_validity_STAR_","subform-validities","custom-get-validity*","subform-validity","fields-to-validate","cljs.core.concat","this-validity","spec-validator","G__65172","com.fulcrologic.fulcro.algorithms.form-state/get-spec-validity","form","G__65182","com.fulcrologic.fulcro.algorithms.form-state/valid-spec?","ui-form","com.fulcrologic.fulcro.algorithms.form_state.get_spec_validity","G__65186","com.fulcrologic.fulcro.algorithms.form-state/invalid-spec?","do-not-care","cljs.core/constantly","carefree-validator","G__65193","com.fulcrologic.fulcro.algorithms.form-state/checked?","cljs.core.not_EQ_","com.fulcrologic.fulcro.algorithms.form-state/immediate-subform-idents","result","com.fulcrologic.fulcro.algorithms.form-state/update-forms","xform","starting-entity-ident","map__65213","vec__65214","config-ident","updated-entity","updated-config","subform-idents","sm","com.fulcrologic.fulcro.algorithms.form-state/strip-tempid-idents","com.fulcrologic.fulcro.algorithms.tempid/tempid?","cljs.core/vec","cljs.core.keep","G__65231","com.fulcrologic.fulcro.algorithms.form-state/dirty-fields","p__65233","map__65234","ui-entity","as-delta?","com.fulcrologic.fulcro.algorithms.form_state.dirty_fields","new-entity?","map__65235","G__65236","delta","before","after","delta-with-refs","old-value","current-value","p1__65223#","has-tempids?","p1__65224#","cljs.core/some","local-dirty-fields","complete-delta","dirty-fields-so-far","subform-join-field","subform","d","f","dirty-subform-fields","G__65243","com.fulcrologic.fulcro.algorithms.form-state/dirty?","map__65245","map__65246","current","original","G__65248","com.fulcrologic.fulcro.algorithms.form-state/clear-complete*","form-config-path","taoensso.timbre._log_BANG_","taoensso.timbre/*config*","cljs.core/Delay","complete-path","cljs.core.update_in","cljs.core.fnil","cljs.core/disj","form-config","G__65262","com.fulcrologic.fulcro.algorithms.form-state/mark-complete*","cljs.core/conj","com.fulcrologic.fulcro.algorithms.form-state/delete-form-state*","entity-ident-or-idents","entity-idents","ks","p__65278","vec__65279","t","r","cljs.core.update","cljs.core.apply","cljs.core/dissoc","com.fulcrologic.fulcro.algorithms.form-state/pristine->entity*","p__65285","map__65286","com.fulcrologic.fulcro.algorithms.form-state/entity->pristine*","p__65294","map__65295","new-pristine-state","com.fulcrologic.fulcro.algorithms.form-state/reset-form!","com.fulcrologic.fulcro.mutations/->Mutation","com.fulcrologic.fulcro.mutations/mutate","fulcro-mutation-env-symbol","map__65298","p__65300","map__65301","*after-render*-orig-val__65304","com.fulcrologic.fulcro.raw.components/*after-render*","*after-render*-temp-val__65305","env","*after-render*-orig-val__65311","*after-render*-temp-val__65312","temp__5753__auto__","com.fulcrologic.fulcro.algorithms.lookup/app-algorithm","default-action","form-ident","ref","state","cljs.core.swap_BANG_","com.fulcrologic.fulcro.algorithms.form-state/mark-complete!","map__65315","p__65317","map__65318","*after-render*-orig-val__65319","*after-render*-temp-val__65320","*after-render*-orig-val__65325","*after-render*-temp-val__65326","com.fulcrologic.fulcro.algorithms.form-state/clear-complete!","map__65333","p__65337","map__65338","*after-render*-orig-val__65340","*after-render*-temp-val__65341","*after-render*-orig-val__65346","*after-render*-temp-val__65347","com.fulcrologic.fulcro.algorithms.form-state/completed-form-props","form-class","com.fulcrologic.fulcro.algorithms.form_state.mark_complete_STAR_","com.fulcrologic.fulcro.algorithms.normalized_state.ui__GT_props","p__65355","map__65356","com.fulcrologic.fulcro.algorithms.form-state/normalize-form*","children","type","original-node","top-component-options","detected-id-key","com.fulcrologic.fulcro.raw.components/ast-id-key","edn-query-language.core/ast->query","form-fields","cljs.core.comp","p1__65353#","cljs.core.filter","cljs.core/namespace","edn-query-language.core/expr->ast","component","args","new-children","p__65364","map__65365","node","G__65367","G__65368","qatom","cljs.core.atom","com.fulcrologic.fulcro.raw.components/configure-anonymous-component!","G__65369","cljs.core/deref","updated-node","query","cljs.core/reset!","G__65374","com.fulcrologic.fulcro.algorithms.form-state/formc","EQL","com.fulcrologic.fulcro.algorithms.form_state.formc","ast"],"sourcesContent":["(ns com.fulcrologic.fulcro.algorithms.form-state\n  \"Functions that assist with supporting form editing/checking/diffing in Fulcro UI.  These functions work\n  by making a pristine copy of your entity, and tracking what fields have been touched.  You are responsible\n  for triggering these various states by marking fields as complete (`mark-complete!`), telling it to\n  copy the data to/from pristine (e.g. `entity->pristine`), and by asking for out-of-date data for the current\n  vs. pristine copy (`dirty-fields`).\n\n  There is also support for detecting which fields have been marked complete and are dirty.\n\n  Validation can be done via Clojure spec (not recommended), or by defining your own field validation functions via\n  `make-validator` (recommended). This general-purpose validation factory function can easily be used to create more\n  automated validation factories that can be more configuration-driven, but this is left as an exercise for the community.\n\n  Specs are not recommended because forms commonly have multi-field dependencies that simply are\n  not well-supported, and sometimes the use of things like Fulcro tempids leads to specs that you'd\n  rather not have on your server. Use of spec really boils down to your intention for those\n  spec (i.e. hard validation of final database value vs. potential runtime look of the data as\n  it is manipulated). Specs that include \\\"state\\\" information will cause you more pain than\n  you want, though you can certainly leverage specs anywhere it makes sense using the validator factory.\n\n  IMPORTANT: This namespace is about *(possibly recursive) form data management*. Rendering and\n  such are not part of the stated intention. See Fulcro RAD for more fully-automated,\n  multi-platform form generation.\n\n  See the Developer's Guide for more information.\n  \"\n  (:require\n    [clojure.spec.alpha :as s]\n    [clojure.set :as set]\n    [taoensso.timbre :as log]\n    [edn-query-language.core :as eql]\n    [com.fulcrologic.guardrails.core :refer [>def >defn >defn- =>]]\n    [com.fulcrologic.fulcro.algorithms.tempid :as tempid]\n    [com.fulcrologic.fulcro.algorithms.normalized-state :as fns]\n    [com.fulcrologic.fulcro.mutations :refer [defmutation]]\n    [com.fulcrologic.fulcro.raw.components :as rc]))\n\n(def ident-generator #(s/gen #{[:table 1] [:other/by-id 9]}))\n\n(>def ::id (s/with-gen eql/ident? ident-generator))         ; form config uses the entity's ident as an ID\n(>def ::fields (s/every keyword? :kind set?))               ; a set of kws that are fields to track\n(>def ::subforms (s/map-of keyword? any?))                  ; a map of subform field to component class\n(>def ::pristine-state (s/map-of keyword? any?))            ; the saved state of the form\n(>def ::complete? (s/every keyword? :kind set?))            ; the fields that have been interacted with\n(>def ::config (s/or :denormalized (s/keys :req [::id ::fields] :opt [::pristine-state ::complete? ::subforms])\n                 :normalized (s/and eql/ident? #(= ::forms-by-ident (first %)))))\n(>def ::validity #{:valid :invalid :unchecked})\n(>def ::denormalized-form (s/keys :req [::config]))\n\n(>defn get-form-fields\n  \"Returns the set of defined form fields for the given component class (or instance).\"\n  [class]\n  [rc/component-class? => (s/nilable ::fields)]\n  (rc/component-options class :form-fields))\n\n(>defn form-id\n  \"Returns the form database table ID for the given entity ident.\"\n  [entity-ident]\n  [(s/cat :id eql/ident?) => map?]\n  {:table (first entity-ident)\n   :row   (second entity-ident)})\n\n(def FormConfig\n  \"A normalizing component supporting normalization of form state configuration. Not really for direct use.\"\n  (rc/nc [::id ::fields ::complete? ::subforms ::pristine-state]\n    {:componentName ::FormConfig\n     :ident         (fn [_ {::keys [id]}]\n                      [::forms-by-ident {:table (first id)\n                                         :row   (second id)}])}))\n\n(def form-config-join\n  \"A query join to ::form-config. This should be added to the query of a component that is\n  using form state support.\"\n  {::config (rc/get-query FormConfig)})\n\n(>defn form-config\n  \"Generate a form config given:\n\n  entity-ident - The ident of the entity you're configuring forms for.\n  fields - A set of keywords on the entity that is the form.\n  subforms - An optional set of keywords on the entity that is the form, for the joins to subforms.\"\n  ([entity-ident fields]\n   [eql/ident? ::fields => ::config]\n   (form-config entity-ident fields {}))\n  ([entity-ident fields subforms]\n   [eql/ident? ::fields ::fields => ::config]\n   {::id       entity-ident\n    ::fields   fields\n    ::subforms (into {}\n                 (map (fn [[k v]] {k (with-meta {} {:component v})}))\n                 subforms)}))\n\n(defn- derive-form-info [class]\n  (let [query-nodes         (some-> class\n                              (rc/get-query)\n                              (eql/query->ast)\n                              :children)\n        query-nodes-by-key  (into {}\n                              (map (fn [n] [(:dispatch-key n) n]))\n                              query-nodes)\n        join-component      (fn [k] (get-in query-nodes-by-key [k :component]))\n        {props :prop joins :join} (group-by :type query-nodes)\n        join-keys           (->> joins (map :dispatch-key) set)\n        prop-keys           (->> props (map :dispatch-key) set)\n        queries-for-config? (contains? join-keys ::config)\n        all-fields          (get-form-fields class)\n        has-fields?         (seq all-fields)\n        fields              (set/intersection all-fields prop-keys)\n        subform-keys        (set/intersection all-fields join-keys)\n        subforms            (into {}\n                              (map (fn [k] [k (with-meta {} {:component (join-component k)})]))\n                              subform-keys)]\n    (when (and has-fields? (not queries-for-config?))\n      (throw (ex-info (str \"Attempt to add form configuration to \" (rc/component-name class) \", but it does not query for config!\")\n               {:offending-component class})))\n    (when (and (not has-fields?) queries-for-config?)\n      (throw (ex-info (str \"Attempt to add form configuration to \" (rc/component-name class) \", but it does not declare any fields!\")\n               {:offending-component class})))\n    [fields subforms subform-keys]))\n\n(>defn add-form-config\n  \"Add form configuration data to a *denormalized* entity (e.g. pre-merge). This is useful in\n  initial state or when using `merge-component!`. This function *will not* touch an entity\n  that already has form config but will recurse the entire form set. It can therefore be\n  invoked on the top-level of the form set when adding, for example, an instance of a sub-form.\n\n  class - The component class.\n  entity - A denormalized (tree) of data that matches the given component class.\n  opts map\n    - :destructive? - If true, overwrites any previous form-config with new re-computed values.\n\n  Returns the (possibly updated) denormalized entity, ready to merge.\"\n  ([class entity]\n   [rc/component-class? map? => map?]\n   (add-form-config class entity {}))\n  ([class entity {:keys [destructive?] :as opts}]\n   [rc/component-class? map? map? => map?]\n   (let [[fields subform-classmap subform-keys] (derive-form-info class)\n         local-entity (if (or (not (contains? entity ::config)) destructive?)\n                        (let [pristine-state (select-keys entity fields)\n                              subform-ident  (fn [k entity] (some-> (get subform-classmap k) meta\n                                                              :component (rc/get-ident entity)))\n                              subform-keys   (-> subform-classmap keys set)\n                              subform-refs   (reduce\n                                               (fn [refs k]\n                                                 (let [items (get entity k)]\n                                                   (cond\n                                                     ; to-one\n                                                     (map? items) (assoc refs k (subform-ident k items))\n                                                     ; to-many\n                                                     (vector? items) (assoc refs k (mapv #(subform-ident k %) items))\n                                                     :else refs)))\n                                               {}\n                                               subform-keys)\n                              pristine-state (merge pristine-state subform-refs)\n                              config         {::id             (rc/get-ident class entity)\n                                              ::fields         fields\n                                              ::pristine-state pristine-state\n                                              ::subforms       (or subform-classmap {})}]\n                          (merge entity {::config config}))\n                        entity)]\n     (reduce\n       (fn [resulting-entity k]\n         (let [c           (some-> subform-classmap (get k) meta :component)\n               has-fields? (boolean (seq (rc/component-options c :form-fields)))\n               child       (get resulting-entity k)]\n           (try\n             (cond\n               (and c has-fields? child (vector? child)) (assoc resulting-entity k (mapv #(add-form-config c % opts) child))\n               (and c has-fields? child) (assoc resulting-entity k (add-form-config c child opts))\n               :else resulting-entity)\n             (catch #?(:clj Exception :cljs :default) e\n               (throw (ex-info (str \"Subform \" (rc/component-name c) \" of \" (rc/component-name class) \" failed to initialize.\")\n                        {:nested-exception e}))))))\n       local-entity\n       subform-keys))))\n\n\n\n(>defn add-form-config*\n  \"Identical to `add-form-config`, but works against normalized entities in the\n  app state. This makes it ideal for composition within mutations.\n\n  state-map - The application state database (map, not atom).\n  class - The component class. Must have declared form fields.\n  entity-ident - The ident of the normalized entity of the given class that you wish to initialize.\n  opts map\n    - :destructive? - If true, overwrites any previous form-config with new re-computed values.\n\n  Returns an updated state map with normalized form configuration in place for the entity.\"\n  ([state-map class entity-ident]\n   [map? rc/component-class? eql/ident? => map?]\n   (add-form-config* state-map class entity-ident {}))\n  ([state-map class entity-ident {:keys [destructive?] :as opts}]\n   [map? rc/component-class? eql/ident? map? => map?]\n   (let [[fields subform-classmap subform-keys] (derive-form-info class)\n         entity            (get-in state-map entity-ident)\n         updated-state-map (if (or destructive? (not (contains? entity ::config)))\n                             (let [pristine-state (select-keys entity (set/union subform-keys fields))\n                                   config         {::id             entity-ident\n                                                   ::fields         fields\n                                                   ::pristine-state pristine-state\n                                                   ::subforms       (or subform-classmap {})}\n                                   cfg-ident      [::forms-by-ident (form-id entity-ident)]]\n                               (-> state-map\n                                 (assoc-in cfg-ident config)\n                                 (assoc-in (conj entity-ident ::config) cfg-ident)))\n                             state-map)]\n     (if (and (empty? fields) (empty? subform-classmap))\n       state-map\n       (reduce\n         (fn [smap subform-key]\n           (let [subform-class  (some-> subform-classmap (get subform-key) meta :component)\n                 subform-target (get entity subform-key)]\n             (try\n               (cond\n                 (and subform-class subform-target (every? eql/ident? subform-target))\n                 (reduce (fn [s subform-ident] (add-form-config* s subform-class subform-ident opts)) smap subform-target)\n\n                 (and subform-class (eql/ident? subform-target))\n                 (add-form-config* smap subform-class subform-target opts)\n\n                 :else smap)\n               (catch #?(:clj Exception :cljs :default) e\n                 (throw (ex-info (str \"Subform \" (rc/component-name subform-class) \" of \" (rc/component-name class) \" failed to initialize.\")\n                          {:nested-exception e}))))))\n         updated-state-map\n         subform-keys)))))\n\n(>defn immediate-subforms\n  \"Get the instances of the immediate subforms that are joined into the given entity by\n   subform-join-keys (works with to-one and to-many).\n\n   - `entity` - a denormalized (UI) entity.\n   - `subform-join-keys` - The keys of the subforms of this entity, as a set.\n\n   Returns a sequence of those entities (all denormalized).\"\n  [entity subform-join-keys]\n  [map? set? => (s/coll-of map?)]\n  (remove nil?\n    (mapcat #(let [v (get entity %)]\n               (if (sequential? v) v [v])) subform-join-keys)))\n\n(>defn no-spec-or-valid?\n  \"Returns false if and only if the given key has a spec, and the spec is not valid for the value found in the given\n  map of entity props (e.g. `(s/valid? key (get entity-props key))`).\n\n  Returns true otherwise.\"\n  [entity-props key]\n  [map? keyword? => boolean?]\n  (or (not (s/get-spec key))\n    (s/valid? key (get entity-props key))))\n\n(defn- merge-validity\n  \"Returns a new validity based on the combination of two.\n\n  * :valid :valid = :valid\n  * :valid :invalid = :invalid\n  * :valid :unchecked = :unchecked\n  * :invalid :valid = :invalid\n  * :invalid :invalid = :invalid\n  * :invalid :unchecked = :unchecked\n  * :unchecked :valid = :unchecked\n  * :unchecked :invalid = :unchecked\n  * :unchecked :unchecked = :unchecked\n  \"\n  [a b]\n  [::validity ::validity => ::validity]\n  (cond\n    (or (= :unchecked a) (= :unchecked b)) :unchecked\n    (and (= :valid a) (= :valid b)) :valid\n    :otherwise :invalid))\n\n(defn make-validator\n  \"Create a form/field validation function using a supplied field checker. The field checker will be given\n  then entire form (denormalized) and a single field key that is to be checked. It must return\n  a boolean indicating if that given field is valid.\n\n  During a recursive check for a form, the validation function will be in the correct context (e.g. the form supplied will contain\n  the field. There is no need to search for it in subforms).\n\n  The options map can contain:\n\n  * `validate-edges?` (default false). When true, the validator will be run on joins that lead to subforms. Normally it runs only on non-join\n  form fields.\n\n  make-validator returns a dual arity function:\n\n  - `(fn [form] ...)` - Calling this version will return :unchecked, :valid, or :invalid for the entire form.\n  - `(fn [form field] ...)` - Calling this version will return :unchecked, :valid, or :invalid for the single field.\n\n  Typical usage would be to show messages around the form fields:\n\n  ```\n  (def field-valid? [form field] true) ; just say everything is valid\n\n  (def my-validator (make-validator field-valid?))\n\n  (defn valid? [form field]\n     (= :valid (my-validator form field)))\n\n  (defn checked? [form field]\n     (not= :unchecked (my-validator form field)))\n  ```\n  \"\n  ([field-valid?]\n   (make-validator field-valid? {:validate-edges? false}))\n  ([field-valid? {:keys [validate-edges?]}]\n   (fn custom-get-validity*\n     ([ui-entity-props field]\n      (let [{{complete? ::complete?} ::config} ui-entity-props\n            complete? (or complete? #{})]\n        (cond\n          (not (complete? field)) :unchecked\n          (not (field-valid? ui-entity-props field)) :invalid\n          :else :valid)))\n     ([ui-entity-props]\n      (let [{{:keys [::fields ::subforms]} ::config} ui-entity-props\n            immediate-subforms (immediate-subforms ui-entity-props (-> subforms keys set))\n            field-validity     (fn [current-validity k] (merge-validity current-validity (custom-get-validity* ui-entity-props k)))\n            subform-validities (map custom-get-validity* immediate-subforms)\n            subform-validity   (reduce merge-validity :valid subform-validities)\n            fields-to-validate (if validate-edges? (concat fields (keys subforms)) fields)\n            this-validity      (reduce field-validity :valid fields-to-validate)]\n        (merge-validity this-validity subform-validity))))))\n\n(let [spec-validator (make-validator no-spec-or-valid?)]\n  (defn get-spec-validity\n    \"Get the validity (:valid :invalid or :unchecked) for the given form/field using Clojure specs of the field keys.\n\n    - `ui-entity-props` : A denormalized (UI) entity, which can have subforms.\n    - `field` : Optional. Returns the validity of just the single field on the top-level form.\n\n    Returns `:invalid` if all of the fields have been interacted with, and *any* are invalid.\n\n    Returns `:unchecked` if any field is not yet been interacted with.\n\n    Fields are marked as having been interacted with by programmatic action on your part via\n    the validate* mutation helper can be used in a mutation to mark fields ready for validation.\n\n    If given a field then it checks just that field.\"\n    ([form] (spec-validator form))\n    ([form field] (spec-validator form field))))\n\n(defn valid-spec?\n  \"Returns true if the given field (or the entire denormalized (UI) form recursively) is :valid\n  according to clojure specs. Returns false if unchecked or invalid. Use `checked-spec?` or `get-spec-validity`\n  for better detail.\"\n  ([ui-form] (= :valid (get-spec-validity ui-form)))\n  ([ui-form field] (= :valid (get-spec-validity ui-form field))))\n\n(defn invalid-spec?\n  \"Returns true if the given field (or any field if only a form is given) in the denormalized (UI) form is :invalid\n  (recursively) according to clojure specs. Returns false if the field is marked unchecked. Use `checked-spec?` or\n  `get-spec-validity` for better detail.\"\n  ([ui-form] (= :invalid (get-spec-validity ui-form)))\n  ([ui-form field] (= :invalid (get-spec-validity ui-form field))))\n\n(let [do-not-care        (constantly true)\n      carefree-validator (make-validator do-not-care)]\n  (defn checked?\n    \"Returns true if the field (or entire denormalized (UI) form) is ready to be checked for validation.\n    Until this returns true validators will simply return :unchecked for a form/field.\"\n    ([ui-form] (not= :unchecked (carefree-validator ui-form)))\n    ([ui-form field]\n     (not= :unchecked (carefree-validator ui-form field)))))\n\n(>defn- immediate-subform-idents\n  \"Get the idents of the immediate subforms that are joined into entity by\n   subform-join-keys (works with to-one and to-many). Entity is a NORMALIZED entity from the state map.\n\n   Returns a sequence of those idents.\"\n  [entity subform-join-keys]\n  [map? (s/coll-of keyword? :kind set?) => (s/coll-of eql/ident?)]\n  (remove nil?\n    (mapcat (fn immediate-subform-idents-step [k]\n              (let [v      (get entity k)\n                    result (cond\n                             (and (sequential? v) (every? eql/ident? v)) v\n                             (eql/ident? v) [v]\n                             :else [])]\n                result)) subform-join-keys)))\n\n(>defn update-forms\n  \"Recursively update a form and its subforms. This function works against the state database (normalized state).\n\n  `state-map` : The application state map\n  `xform` : A function (fn [entity form-config] [entity' form-config']) that is passed the normalized entity and form-config,\n    and must return an updated version of them.\n  `starting-entity-ident` : An ident in the state map of an entity that has been initialized as a form.\n\n  Returns the updated state map.\"\n  [state-map xform starting-entity-ident]\n  [map? fn? eql/ident? => map?]\n  (let [entity         (get-in state-map starting-entity-ident)\n        config-ident   (get entity ::config)\n        config         (get-in state-map config-ident)\n        {:keys [::subforms]} config\n        [updated-entity updated-config] (xform entity config)\n        subform-idents (immediate-subform-idents (get-in state-map starting-entity-ident) (-> subforms keys set))]\n    (if config-ident\n      (as-> state-map sm\n        (assoc-in sm starting-entity-ident updated-entity)\n        (assoc-in sm config-ident updated-config)\n        (reduce (fn [s id]\n                  (update-forms s xform id)) sm subform-idents))\n      state-map)))\n\n(defn- strip-tempid-idents\n  \"Remote tempid idents from to-one or to-many values\"\n  [v]\n  (cond\n    (and (eql/ident? v) (tempid/tempid? (second v)))\n    nil\n\n    (and (vector? v) (every? eql/ident? v)) (vec (keep strip-tempid-idents v))\n\n    :else v))\n\n(>defn dirty-fields\n  \"Obtains all of the dirty fields for the given (denormalized) ui-entity, recursively. This works against UI props\n  because submission mutations should close over the data as parameters to a mutation. In other words, your form\n  submission to a server should be triggered from UI with the output of this function as parameters:\n\n  ```\n  (dom/input { :onClick #(comp/transact! this `[(some-submit-function {:diff ~(f/dirty-fields props true)})]) })\n  ```\n\n  - `ui-entity` - The entity (denormalized) from the UI.\n  - `as-delta?` - If false, each field's reported (new) value will just be the new value. When true, each value will be a map with :before and :after keys\n  with the old and new values (useful for optimistic transaction semantics).\n\n  Returns a map keyed by form ID (for each form/subform) whose values are maps of key/value pairs of\n  changes. Fields from entities that have a temporary IDs will always be included.\n\n  In other words, a change that happened for an entity with ident `entity-ident` on field `:field`:\n\n  With `as-delta?` true:\n\n  ```\n  {entity-ident {:field {:before 1 :after 2}}}\n  ```\n\n  with `as-delta?` false:\n\n  ```\n  {entity-ident {:field 2}}\n  ```\n\n  If ui-entity has tempid in ident or has `:new-entity? true` in opts map, then all fields for that form will be\n  included in result regardless of pristine state.\n  \"\n  ([ui-entity as-delta?]\n   [map? boolean? => map?]\n   (dirty-fields ui-entity as-delta? {}))\n  ([ui-entity as-delta? {:keys [new-entity?] :as opts}]\n   [map? boolean? map? => map?]\n   (let [{:keys [::id ::fields ::pristine-state ::subforms] :as config} (get ui-entity ::config)\n         subform-keys       (-> subforms keys set)\n         subform-ident      (fn [k entity] (some-> (get subforms k) meta :component (rc/get-ident entity)))\n         new-entity?        (or new-entity? (tempid/tempid? (second id)))\n         delta              (into {} (keep (fn [k]\n                                             (let [before (get pristine-state k)\n                                                   after  (get ui-entity k)]\n                                               (if (or new-entity? (not= before after))\n                                                 (if as-delta?\n                                                   [k {:before before :after after}]\n                                                   [k after])\n                                                 nil))) fields))\n         delta-with-refs    (into delta\n                              (keep\n                                (fn [k]\n                                  (let [items         (get ui-entity k)\n                                        old-value     (get-in ui-entity [::config ::pristine-state k])\n                                        current-value (cond\n                                                        (map? items) (subform-ident k items)\n                                                        (vector? items) (mapv #(subform-ident k %) items)\n                                                        :else items)\n                                        has-tempids?  (if (every? eql/ident? current-value)\n                                                        (some #(tempid/tempid? (second %)) current-value)\n                                                        (tempid/tempid? (second current-value)))]\n                                    (if (or new-entity? has-tempids? (not= old-value current-value))\n                                      (let [old-value (strip-tempid-idents old-value)]\n                                        (if as-delta?\n                                          [k {:before old-value :after current-value}]\n                                          [k current-value]))\n                                      nil)))\n                                subform-keys))\n         local-dirty-fields (if (empty? delta-with-refs) {} {id delta-with-refs})\n         complete-delta     (reduce\n                              (fn [dirty-fields-so-far subform-join-field]\n                                (let [subform (get ui-entity subform-join-field)]\n                                  (cond\n                                    ; to many\n                                    (vector? subform) (reduce (fn [d f] (merge d (dirty-fields f as-delta? opts))) dirty-fields-so-far subform)\n                                    ; to one\n                                    (map? subform) (let [dirty-subform-fields (dirty-fields subform as-delta? opts)]\n                                                     (merge dirty-fields-so-far dirty-subform-fields))\n                                    ; missing subform\n                                    :else dirty-fields-so-far)))\n                              local-dirty-fields\n                              subform-keys)]\n     complete-delta)))\n\n(>defn dirty?\n  \"Returns true if the given ui-entity-props that are configured as a form differ from the pristine version.\n  Recursively follows subforms if given no field. Returns true if anything doesn't match up.\n\n  If given a field, it only checks that field.\"\n  ([ui-entity-props field]\n   [map? keyword? => boolean?]\n   (let [{{pristine-state ::pristine-state} ::config} ui-entity-props\n         current  (get ui-entity-props field)\n         original (get pristine-state field)]\n     (not= current original)))\n  ([ui-entity-props]\n   [map? => boolean?]\n   (boolean (seq (dirty-fields ui-entity-props false)))))\n\n(defn clear-complete*\n  \"Mark the fields incomplete so that validation checks will no longer return values. This function works on an app state database\n  map (not atom) and is meant to be composed into mutations. See the `mark-incomplete!` mutation if you do not need to combine\n  this with other operations.\n\n  Follows the subforms recursively through state, unless a specific field is given.\"\n  ([state-map entity-ident field]\n   (let [form-config-path (conj entity-ident ::config)\n         form-config-path (if (eql/ident? (get-in state-map form-config-path))\n                            (get-in state-map form-config-path)\n                            (do\n                              (log/error (str \"FORM NOT NORMALIZED: \" entity-ident))\n                              form-config-path))\n         complete-path    (conj form-config-path ::complete?)]\n     (update-in state-map complete-path (fnil disj #{}) field)))\n  ([state-map entity-ident]\n   (update-forms state-map\n     (fn mark*-step [e form-config]\n       [e (assoc form-config ::complete? #{})]) entity-ident)))\n\n(>defn mark-complete*\n  \"Mark the fields complete so that validation checks will return values. This function works on a app state database\n  map (not atom) and is meant to be composed into mutations. See the `mark-complete!` mutation if you do not need to combine\n  this with other operations.\n\n  Follows the subforms recursively through state, unless a specific field is given.\"\n  ([state-map entity-ident field]\n   [map? eql/ident? keyword? => map?]\n   (let [form-config-path (conj entity-ident ::config)\n         form-config-path (if (eql/ident? (get-in state-map form-config-path))\n                            (get-in state-map form-config-path)\n                            (do\n                              (log/error (str \"FORM NOT NORMALIZED: \" entity-ident \"See https://book.fulcrologic.com/#err-fs-form-not-normalized\"))\n                              form-config-path))\n         complete-path    (conj form-config-path ::complete?)]\n     (update-in state-map complete-path (fnil conj #{}) field)))\n  ([state-map entity-ident]\n   [map? eql/ident? => map?]\n   (update-forms state-map\n     (fn mark*-step [e form-config]\n       [e (assoc form-config ::complete? (into (::fields form-config)\n                                           (keys (::subforms form-config))))]) entity-ident)))\n\n(>defn delete-form-state*\n  \"Removes copies of entities used by form-state logic.\"\n  [state-map entity-ident-or-idents]\n  [map? (s/or :i eql/ident? :is (s/coll-of eql/ident?)) => map?]\n  (let [entity-idents (if (eql/ident? entity-ident-or-idents)\n                        [entity-ident-or-idents]\n                        entity-ident-or-idents)\n\n        ks            (mapv (fn [[t r]]\n                              {:table t :row r})\n                        entity-idents)]\n    (update state-map ::forms-by-ident\n      (fn [s]\n        (apply dissoc s ks)))))\n\n(>defn pristine->entity*\n  \"Copy the pristine state over top of the originating entity of the given form. Meant to be used inside of a\n  mutation. Recursively follows subforms in app state. Returns the new app state map.\n\n  state-map - The normalized state database (map, not atom)\n  entity-ident - The ident of the entity that you wish to restore to its original pristine state.\n\n  Only affects declared fields and sub-forms.\"\n  [state-map entity-ident]\n  [map? eql/ident? => map?]\n  (update-forms state-map (fn reset-form-step [e {::keys [fields pristine-state] :as config}]\n                            [(as-> e e (apply dissoc e fields) (merge e pristine-state)) config]) entity-ident))\n\n(>defn entity->pristine*\n  \"Overwrite the pristine state (form state's copy) of the entity. This is meant to be used from a mutation\n  to update the form state tracking recursively to make the form as 'unmodified'. That is to say, as if you\n  committed the values to the server, and the current entity state is now the pristine state.\n\n  This function does no sanity checks, so you should ensure the entity is valid!\n\n  Recursively updates all sub forms.\n\n  Returns the updated state-map (database).\"\n  [state-map entity-ident]\n  [map? eql/ident? => map?]\n  (update-forms state-map (fn commit-form-step [e {:keys [::fields ::subforms] :as config}]\n                            (let [subform-keys       (-> subforms keys set)\n                                  new-pristine-state (select-keys e (set/union subform-keys fields))]\n                              [e (assoc config ::pristine-state new-pristine-state)])) entity-ident))\n\n(defmutation reset-form!\n  \"Mutation: Reset the form (recursively) to its (last recorded) pristine state. If form ident is not supplied it uses the ident\n   of the calling component. See `pristine->entity*` for a function you can compose into your own mutations.\"\n  [{:keys [form-ident]}]\n  (action [{:keys [ref state]}]\n    (swap! state pristine->entity* (or form-ident ref))))\n\n(defmutation mark-complete!\n  \"Mutation: Mark a given form (recursively) or field complete.\n\n  entity-ident - The ident of the entity to mark complete. This is optional, but if not supplied it will derive it from\n                 the ident of the invoking component.\n  field - (optional) limit the marking to a single field.\n\n  See `mark-complete*` for a function you can compose into your own mutations.\"\n  [{:keys [entity-ident field]}]\n  (action [{:keys [ref state]}]\n    (let [entity-ident (or entity-ident ref)]\n      (if field\n        (swap! state mark-complete* entity-ident field)\n        (swap! state mark-complete* entity-ident)))))\n\n(defmutation clear-complete!\n  \"Mutation: Mark a given form (recursively) or field incomplete.\n\n  entity-ident - The ident of the entity to mark. This is optional, but if not supplied it will derive it from\n                 the ident of the invoking component.\n  field - (optional) limit the marking to a single field.\n\n  See `clear-complete*` for a function you can compose into your own mutations.\"\n  [{:keys [entity-ident field]}]\n  (action [{:keys [ref state]}]\n    (let [entity-ident (or entity-ident ref)]\n      (if field\n        (swap! state clear-complete* entity-ident field)\n        (swap! state clear-complete* entity-ident)))))\n\n(defn completed-form-props\n  \"Calculates and returns the (ui) props of the given form-class based upon marking the form in the given state-map\n  complete, and then using the query of the form-class to pull the props. This function is useful in mutations and\n  other back-end logic that has access to the Fulcro database, but needs to call other support functions in this\n  namespace where the form props are required.\n\n  - `state-map`: The Fulcro normalized database\n  - `form-class`: The form component class (an instance is also acceptable)\n  - `form-ident`: The ident of the form instance to pull props for.\n\n  Returns a tree of UI props where all fields have been marked complete.\n  \"\n  [state-map form-class form-ident]\n  (-> state-map\n    (mark-complete* form-ident)\n    (fns/ui->props form-class form-ident)))\n\n(defn- normalize-form* [{:keys [children type] :as original-node} top-component-options]\n  (let [detected-id-key (or (rc/ast-id-key children) (throw (ex-info \"Query must have an ID field for normalization detection\" {:query (eql/ast->query original-node)})))\n        _               detected-id-key\n        form-fields     (into #{}\n                          (comp\n                            (map :key)\n                            (filter #(and\n                                       (not (vector? %))\n                                       (not= \"ui\" (namespace %))\n                                       (not= % detected-id-key))))\n                          children)\n        children        (conj children (eql/expr->ast form-config-join))\n        component       (fn [& args])\n        new-children    (mapv\n                          (fn [{:keys [type] :as node}]\n                            (if (and (= type :join) (not (:component node)))\n                              (normalize-form* node {})\n                              node))\n                          children)\n        qatom           (atom nil)\n        component       (rc/configure-anonymous-component! component (cond-> (with-meta\n                                                                               (merge\n                                                                                 {:initial-state (fn [& args] {})}\n                                                                                 top-component-options\n                                                                                 {:query       (fn [& args] @qatom)\n                                                                                  :ident       (fn [_ props] [detected-id-key (get props detected-id-key)])\n                                                                                  :form-fields form-fields\n                                                                                  \"props\"      {\"fulcro$queryid\" :anonymous}})\n                                                                               {:query-id :anonymous})))\n        updated-node    (assoc original-node :children new-children :component component)\n        query           (if (= type :join)\n                          (eql/ast->query (assoc updated-node :type :root))\n                          (eql/ast->query updated-node))\n        _               (reset! qatom query)]\n    updated-node))\n\n(defn formc\n  \"Create an anonymous normalizing form component from EQL. Every level of the query MUST\n   have an `:<???>/id` field which is used to build the ident, and every non-id attribute will be considered part\n   of the form except:\n\n   * Props in the namespace `ui` like `:ui/checked?`\n   * Idents list `[:component/id :thing]`\n   * Root links like `[:root/key '_]`\n\n   This function also auto-adds the necessary form-state form join, and populates the anonymous component with the\n   `:form-fields` option. You can add additional component options to the top-level anonymous component with\n   `top-component-options`.\n\n   See also `nc`, which is similar but does not autogenerate form-related add-ins.\"\n  ([EQL] (formc EQL {}))\n  ([EQL top-component-options]\n   (let [ast (eql/query->ast EQL)]\n     (:component (normalize-form* ast top-component-options)))))\n"]}